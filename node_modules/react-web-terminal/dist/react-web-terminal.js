(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"));
	else if(typeof define === 'function' && define.amd)
		define(["React"], factory);
	else if(typeof exports === 'object')
		exports["WebTerminal"] = factory(require("React"));
	else
		root["WebTerminal"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_6__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(1);
	
	var _reactWebTerminal = __webpack_require__(5);
	
	var _reactWebTerminal2 = _interopRequireDefault(_reactWebTerminal);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = _reactWebTerminal2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(2);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/index.js?outputStyle=expanded&includePaths[]=/Users/jyannes/development/react-web-terminal/bower_components&includePaths[]=/Users/jyannes/development/react-web-terminal/node_modules!./react-web-terminal.scss", function() {
				var newContent = require("!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/index.js?outputStyle=expanded&includePaths[]=/Users/jyannes/development/react-web-terminal/bower_components&includePaths[]=/Users/jyannes/development/react-web-terminal/node_modules!./react-web-terminal.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "@keyframes cursor-blink {\n  50% {\n    background-color: #fff;\n  }\n}\n\n.react-web-terminal {\n  height: calc(100% - (2 * 16px));\n  width: calc(100% - (2 * 16px));\n  padding: 16px;\n  background-color: #000;\n  color: #fff;\n  font-family: monospace;\n  overflow: scroll;\n}\n\n.react-web-terminal pre {\n  font-family: monospace;\n  margin: 0;\n}\n\n.react-web-terminal .react-web-terminal-input {\n  white-space: nowrap;\n}\n\n.react-web-terminal:focus .react-web-terminal-input .react-web-terminal-input-buffer .react-web-terminal-cursor {\n  animation: cursor-blink 1s linear infinite;\n}\n", ""]);
	
	// exports


/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(6);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactWebTerminalKeyboardData = __webpack_require__(7);
	
	var _reactWebTerminalInput = __webpack_require__(8);
	
	var _reactWebTerminalInput2 = _interopRequireDefault(_reactWebTerminalInput);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var WebTerminal = function (_React$Component) {
	  _inherits(WebTerminal, _React$Component);
	
	  // TODO add inline styles so they can be changed dynamically
	  // TODO add ability to disable/enable input buffer
	  // TODO add ajax call function that disables input then re-enables after callback runs
	  // TODO unicode support
	  function WebTerminal(props) {
	    _classCallCheck(this, WebTerminal);
	
	    var _this = _possibleConstructorReturn(this, (WebTerminal.__proto__ || Object.getPrototypeOf(WebTerminal)).call(this, props));
	
	    _this.state = {
	      log: [],
	      logId: 0,
	      commandHandler: props.commandHandler ? props.commandHandler : function (component) {
	        return component.output(component.input());
	      },
	      keyStrokeMap: props.keyStrokeMap || {},
	      style: {
	        reactWebTerminal: {},
	        reactWebTerminalInput: {},
	        reactWebTerminalInputBuffer: {},
	        reactWebTerminalCursor: {}
	      }
	    };
	    return _this;
	  }
	
	  _createClass(WebTerminal, [{
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      this.root.scrollTop = this.root.scrollHeight;
	    }
	  }, {
	    key: 'addToLog',
	    value: function addToLog(text, className) {
	      this.state.log.push({
	        'id': this.state.logId,
	        'class': className,
	        'text': text
	      });
	
	      this.state.logId++;
	
	      this.setState(this.state);
	    }
	  }, {
	    key: 'input',
	    value: function input() {
	      return this.inputComp.getInput();
	    }
	  }, {
	    key: 'output',
	    value: function output(_output) {
	      this.addToLog(_output, 'react-web-terminal-output');
	
	      this.resetInputBuffer();
	
	      this.setState(this.state);
	    }
	  }, {
	    key: 'resetInputBuffer',
	    value: function resetInputBuffer() {
	      this.inputComp.resetInputBuffer();
	    }
	  }, {
	    key: 'handleKeyDown',
	    value: function handleKeyDown(e) {
	      if (!this.keyStrokeMapHandler(e)) this.inputComp.handleKeyDown(e);
	    }
	  }, {
	    key: 'onPaste',
	    value: function onPaste(e) {
	      this.inputComp.onPaste(e);
	    }
	  }, {
	    key: 'onCommandEntered',
	    value: function onCommandEntered() {
	      this.addToLog(this.inputComp.state.prompt + this.input(), 'react-web-terminal-input');
	      this.state.commandHandler(this);
	    }
	  }, {
	    key: 'keyStrokeMapHandler',
	    value: function keyStrokeMapHandler(e) {
	      var keyStroke = (0, _reactWebTerminalKeyboardData.getKeyStroke)(e);
	      if (keyStroke in this.state.keyStrokeMap) return this.state.keyStrokeMap[keyStroke](this) !== false ? true : false;else return false;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var logNodes = this.state.log.map(function (item) {
	        return _react2.default.createElement(
	          'div',
	          { key: item.id, className: item.class },
	          _react2.default.createElement(
	            'pre',
	            null,
	            item.text
	          )
	        );
	      });
	
	      return _react2.default.createElement(
	        'div',
	        { tabIndex: '-1', ref: function ref(root) {
	            _this2.root = root;
	          }, className: 'react-web-terminal', onKeyDown: this.handleKeyDown.bind(this), onPaste: this.onPaste.bind(this) },
	        logNodes,
	        _react2.default.createElement(_reactWebTerminalInput2.default, { ref: function ref(input) {
	            _this2.inputComp = input;
	          }, prompt: this.props.prompt, onCommandEntered: this.onCommandEntered.bind(this) })
	      );
	    }
	  }]);
	
	  return WebTerminal;
	}(_react2.default.Component);
	
	exports.default = WebTerminal;

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = React;

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getKey = getKey;
	exports.getKeyStroke = getKeyStroke;
	var keymap = {
	    8: ['Backspace', 'Backspace'],
	    9: ['Tab', 'Tab'],
	
	    12: ['Clear', 'Clear'],
	    13: ['Enter', 'Enter'],
	
	    16: ['Shift', 'Shift'],
	    17: ['Control', 'Control'],
	    18: ['Alt', 'Alt'],
	
	    20: ['CapsLock', 'CapsLock'],
	
	    27: ['Escape', 'Escape'],
	
	    32: [' ', ' '],
	    33: ['PageUp', 'PageUp'],
	    34: ['PageDown', 'PageDown'],
	    35: ['End', 'End'],
	    36: ['Home', 'Home'],
	    37: ['ArrowLeft', 'ArrowLeft'],
	    38: ['ArrowUp', 'ArrowUp'],
	    39: ['ArrowRight', 'ArrowRight'],
	    40: ['ArrowDown', 'ArrowDown'],
	
	    46: ['Delete', 'Delete'],
	
	    48: ['0', ')'],
	    49: ['1', '!'],
	    50: ['2', '@'],
	    51: ['3', '#'],
	    52: ['4', '$'],
	    53: ['5', '%'],
	    54: ['6', '^'],
	    55: ['7', '&'],
	    56: ['8', '*'],
	    57: ['9', '('],
	
	    65: ['a', 'A'],
	    66: ['b', 'B'],
	    67: ['c', 'C'],
	    68: ['d', 'D'],
	    69: ['e', 'E'],
	    70: ['f', 'F'],
	    71: ['g', 'G'],
	    72: ['h', 'H'],
	    73: ['i', 'I'],
	    74: ['j', 'J'],
	    75: ['k', 'K'],
	    76: ['l', 'L'],
	    77: ['m', 'M'],
	    78: ['n', 'N'],
	    79: ['o', 'O'],
	    80: ['p', 'P'],
	    81: ['q', 'Q'],
	    82: ['r', 'R'],
	    83: ['s', 'S'],
	    84: ['t', 'T'],
	    85: ['u', 'U'],
	    86: ['v', 'V'],
	    87: ['w', 'W'],
	    88: ['x', 'X'],
	    89: ['y', 'Y'],
	    90: ['z', 'Z'],
	    91: ['Meta', 'Meta'],
	
	    106: ['*', '*'],
	    107: ['+', '+'],
	
	    109: ['-', '-'],
	    110: ['.', '.'],
	    111: ['/', '/'],
	    112: ['F1', 'F1'],
	    113: ['F2', 'F2'],
	    114: ['F3', 'F3'],
	    115: ['F4', 'F4'],
	    116: ['F5', 'F5'],
	    117: ['F6', 'F6'],
	    118: ['F7', 'F7'],
	    119: ['F8', 'F8'],
	    120: ['F9', 'F9'],
	    121: ['F10', 'F10'],
	    122: ['F11', 'F11'],
	    123: ['F12', 'F12'],
	    124: ['F13', 'F13'],
	    125: ['F14', 'F14'],
	    126: ['F15', 'F15'],
	    127: ['F16', 'F16'],
	    128: ['F17', 'F17'],
	    129: ['F18', 'F18'],
	    130: ['F19', 'F19'],
	
	    186: [';', ':'],
	    187: ['=', '+'],
	    188: [',', '<'],
	    189: ['-', '_'],
	    190: ['.', '>'],
	    191: ['/', '?'],
	    192: ['`', '~'],
	
	    219: ['[', '{'],
	    220: ['\\', '|'],
	    221: [']', '}'],
	    222: ['\'', '"']
	
	};
	
	function getKey(e) {
	    var key = '';
	    if (e.key && e.key !== 'Unidentified') {
	        key = e.key;
	    } else {
	        key = e.shiftKey ? keymap[e.which][1] : keymap[e.which][0];
	    }
	    return key;
	}
	
	function getKeyStroke(e) {
	    var keyTemp = getKey(e);
	    var key = keyTemp === ' ' ? 'Space' : keyTemp;
	
	    var keyStroke = [];
	    if (e.ctrlKey || key === 'Control') keyStroke.push('Control');
	    if (e.altKey || key === 'Alt') keyStroke.push('Alt');
	    if (e.metaKey || key === 'Meta') keyStroke.push('Meta');
	    if (e.shiftKey || key === 'Shift') keyStroke.push('Shift');
	    if (keyStroke.indexOf(key) === -1) keyStroke.push(key);
	
	    return keyStroke.join('+');
	}
	
	var nonPrintableKeys = exports.nonPrintableKeys = ['Backspace', 'Tab', 'Clear', 'Enter', 'Shift', 'Control', 'Alt', 'CapsLock', 'Escape', 'PageUp', 'PageDown', 'End', 'Home', 'ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown', 'Delete', 'Meta', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12', 'F13', 'F14', 'F15', 'F16', 'F17', 'F18', 'F19'];

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(6);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactWebTerminalInputBuffer = __webpack_require__(9);
	
	var _reactWebTerminalInputBuffer2 = _interopRequireDefault(_reactWebTerminalInputBuffer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var WebTerminalInput = function (_React$Component) {
	  _inherits(WebTerminalInput, _React$Component);
	
	  function WebTerminalInput(props) {
	    _classCallCheck(this, WebTerminalInput);
	
	    var _this = _possibleConstructorReturn(this, (WebTerminalInput.__proto__ || Object.getPrototypeOf(WebTerminalInput)).call(this, props));
	
	    _this.state = {
	      prompt: props.prompt ? props.prompt : '> '
	    };
	    return _this;
	  }
	
	  _createClass(WebTerminalInput, [{
	    key: 'getInput',
	    value: function getInput() {
	      return this.buffer.getInput();
	    }
	  }, {
	    key: 'resetInputBuffer',
	    value: function resetInputBuffer() {
	      this.buffer.resetInputBuffer();
	    }
	  }, {
	    key: 'handleKeyDown',
	    value: function handleKeyDown(e) {
	      this.buffer.handleKeyDown(e);
	    }
	  }, {
	    key: 'onPaste',
	    value: function onPaste(e) {
	      this.buffer.onPaste(e);
	    }
	  }, {
	    key: 'onCommandEntered',
	    value: function onCommandEntered() {
	      if (this.props.onCommandEntered) this.props.onCommandEntered();
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'react-web-terminal-input' },
	        _react2.default.createElement(
	          'pre',
	          null,
	          this.state.prompt,
	          _react2.default.createElement(_reactWebTerminalInputBuffer2.default, { ref: function ref(buffer) {
	              _this2.buffer = buffer;
	            }, onCommandEntered: this.onCommandEntered.bind(this) })
	        )
	      );
	    }
	  }]);
	
	  return WebTerminalInput;
	}(_react2.default.Component);
	
	exports.default = WebTerminalInput;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(6);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactWebTerminalKeyboardData = __webpack_require__(7);
	
	var _reactWebTerminalCursor = __webpack_require__(10);
	
	var _reactWebTerminalCursor2 = _interopRequireDefault(_reactWebTerminalCursor);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var WebTerminalInputBuffer = function (_React$Component) {
	  _inherits(WebTerminalInputBuffer, _React$Component);
	
	  function WebTerminalInputBuffer(props) {
	    _classCallCheck(this, WebTerminalInputBuffer);
	
	    var _this = _possibleConstructorReturn(this, (WebTerminalInputBuffer.__proto__ || Object.getPrototypeOf(WebTerminalInputBuffer)).call(this, props));
	
	    _this.state = {
	      input: ''
	    };
	    return _this;
	  }
	
	  _createClass(WebTerminalInputBuffer, [{
	    key: 'getInput',
	    value: function getInput() {
	      return this.state.input;
	    }
	  }, {
	    key: 'resetInputBuffer',
	    value: function resetInputBuffer() {
	      this.state.input = '';
	      this.cursor.moveToBegining();
	    }
	  }, {
	    key: 'insertText',
	    value: function insertText(text) {
	      this.state.input = this.getPreCursorStr() + text + this.cursor.getCursorChar() + this.getPostCursorStr();
	      this.cursor.moveRight(text.length);
	      this.setState(this.state);
	    }
	  }, {
	    key: 'handleKeyDown',
	    value: function handleKeyDown(e) {
	      var key = (0, _reactWebTerminalKeyboardData.getKey)(e);
	      if (key === 'Enter') {
	        this.onCommandEntered();
	      } else if (key === 'Backspace') {
	        var newPreCursorStr = this.getPreCursorStr().slice(0, this.getPreCursorStr().length - 1);
	        this.state.input = newPreCursorStr + this.cursor.getCursorChar() + this.getPostCursorStr();
	        this.cursor.moveLeft();
	        this.setState(this.state);
	      } else if (key === 'ArrowLeft') {
	        this.cursor.moveLeft();
	        this.forceUpdate();
	      } else if (key === 'ArrowRight') {
	        this.cursor.moveRight();
	        this.forceUpdate();
	      } else if (_reactWebTerminalKeyboardData.nonPrintableKeys.indexOf(key) === -1 && !e.altKey && !e.ctrlKey && !e.metaKey) {
	        this.insertText(key);
	      }
	    }
	  }, {
	    key: 'onPaste',
	    value: function onPaste(e) {
	      var pastedText = e.clipboardData.getData('Text');
	      this.insertText(pastedText);
	    }
	  }, {
	    key: 'onCommandEntered',
	    value: function onCommandEntered() {
	      if (this.props.onCommandEntered) this.props.onCommandEntered();
	    }
	  }, {
	    key: 'getPreCursorStr',
	    value: function getPreCursorStr() {
	      var cursorPos = this.cursor ? this.cursor.getCursorPos() : 0;
	      return this.getInput().slice(0, cursorPos);
	    }
	  }, {
	    key: 'getPostCursorStr',
	    value: function getPostCursorStr() {
	      var cursorPos = this.cursor ? this.cursor.getCursorPos() : 0;
	      return this.getInput().slice(cursorPos + 1, this.getInput().length);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'span',
	        { className: 'react-web-terminal-input-buffer' },
	        this.getPreCursorStr(),
	        _react2.default.createElement(_reactWebTerminalCursor2.default, { ref: function ref(cursor) {
	            _this2.cursor = cursor;
	          }, inputMethod: this.getInput.bind(this) }),
	        this.getPostCursorStr()
	      );
	    }
	  }]);
	
	  return WebTerminalInputBuffer;
	}(_react2.default.Component);
	
	exports.default = WebTerminalInputBuffer;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(6);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var WebTerminalCursor = function (_React$Component) {
	  _inherits(WebTerminalCursor, _React$Component);
	
	  function WebTerminalCursor(props) {
	    _classCallCheck(this, WebTerminalCursor);
	
	    var _this = _possibleConstructorReturn(this, (WebTerminalCursor.__proto__ || Object.getPrototypeOf(WebTerminalCursor)).call(this, props));
	
	    _this.state = {
	      cursorPos: 0
	    };
	    return _this;
	  }
	
	  _createClass(WebTerminalCursor, [{
	    key: 'getInput',
	    value: function getInput() {
	      return this.props.inputMethod ? this.props.inputMethod() : '';
	    }
	  }, {
	    key: 'getCursorPos',
	    value: function getCursorPos() {
	      return this.state.cursorPos;
	    }
	  }, {
	    key: 'setCursorPos',
	    value: function setCursorPos(newPos) {
	      this.state.cursorPos = newPos;
	      this.setState(this.state);
	    }
	  }, {
	    key: 'moveLeft',
	    value: function moveLeft() {
	      var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	
	      if (this.state.cursorPos > 0) this.setCursorPos(this.getCursorPos() - amount);
	    }
	  }, {
	    key: 'moveRight',
	    value: function moveRight() {
	      var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	
	      if (this.state.cursorPos < this.getInput().length) this.setCursorPos(this.getCursorPos() + amount);
	    }
	  }, {
	    key: 'moveToBegining',
	    value: function moveToBegining() {
	      this.setCursorPos(0);
	    }
	  }, {
	    key: 'moveToEnd',
	    value: function moveToEnd() {
	      this.setCursorPos(this.getInput().length);
	    }
	  }, {
	    key: 'getCursorChar',
	    value: function getCursorChar() {
	      return this.getInput().charAt(this.getCursorPos());
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var cursorChar = this.getCursorChar();
	      return _react2.default.createElement(
	        'span',
	        { className: 'react-web-terminal-cursor' },
	        cursorChar === '' ? ' ' : cursorChar
	      );
	    }
	  }]);
	
	  return WebTerminalCursor;
	}(_react2.default.Component);
	
	exports.default = WebTerminalCursor;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA0YWExMjBhMGM1YWEzNTRlZWE2NCIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvcmVhY3Qtd2ViLXRlcm1pbmFsL3JlYWN0LXdlYi10ZXJtaW5hbC5zY3NzPzM0MjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvcmVhY3Qtd2ViLXRlcm1pbmFsL3JlYWN0LXdlYi10ZXJtaW5hbC5zY3NzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3JlYWN0LXdlYi10ZXJtaW5hbC9yZWFjdC13ZWItdGVybWluYWwuanN4Iiwid2VicGFjazovLy9leHRlcm5hbCBcIlJlYWN0XCIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvcmVhY3Qtd2ViLXRlcm1pbmFsL3JlYWN0LXdlYi10ZXJtaW5hbC1rZXlib2FyZC1kYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3JlYWN0LXdlYi10ZXJtaW5hbC9yZWFjdC13ZWItdGVybWluYWwtaW5wdXQuanN4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3JlYWN0LXdlYi10ZXJtaW5hbC9yZWFjdC13ZWItdGVybWluYWwtaW5wdXQtYnVmZmVyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9yZWFjdC13ZWItdGVybWluYWwvcmVhY3Qtd2ViLXRlcm1pbmFsLWN1cnNvci5qc3giXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIldlYlRlcm1pbmFsIiwicHJvcHMiLCJzdGF0ZSIsImxvZyIsImxvZ0lkIiwiY29tbWFuZEhhbmRsZXIiLCJjb21wb25lbnQiLCJvdXRwdXQiLCJpbnB1dCIsImtleVN0cm9rZU1hcCIsInN0eWxlIiwicmVhY3RXZWJUZXJtaW5hbCIsInJlYWN0V2ViVGVybWluYWxJbnB1dCIsInJlYWN0V2ViVGVybWluYWxJbnB1dEJ1ZmZlciIsInJlYWN0V2ViVGVybWluYWxDdXJzb3IiLCJyb290Iiwic2Nyb2xsVG9wIiwic2Nyb2xsSGVpZ2h0IiwidGV4dCIsImNsYXNzTmFtZSIsInB1c2giLCJzZXRTdGF0ZSIsImlucHV0Q29tcCIsImdldElucHV0IiwiYWRkVG9Mb2ciLCJyZXNldElucHV0QnVmZmVyIiwiZSIsImtleVN0cm9rZU1hcEhhbmRsZXIiLCJoYW5kbGVLZXlEb3duIiwib25QYXN0ZSIsInByb21wdCIsImtleVN0cm9rZSIsImxvZ05vZGVzIiwibWFwIiwiaXRlbSIsImlkIiwiY2xhc3MiLCJiaW5kIiwib25Db21tYW5kRW50ZXJlZCIsIkNvbXBvbmVudCIsImdldEtleSIsImdldEtleVN0cm9rZSIsImtleW1hcCIsImtleSIsInNoaWZ0S2V5Iiwid2hpY2giLCJrZXlUZW1wIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJpbmRleE9mIiwiam9pbiIsIm5vblByaW50YWJsZUtleXMiLCJXZWJUZXJtaW5hbElucHV0IiwiYnVmZmVyIiwiV2ViVGVybWluYWxJbnB1dEJ1ZmZlciIsImN1cnNvciIsIm1vdmVUb0JlZ2luaW5nIiwiZ2V0UHJlQ3Vyc29yU3RyIiwiZ2V0Q3Vyc29yQ2hhciIsImdldFBvc3RDdXJzb3JTdHIiLCJtb3ZlUmlnaHQiLCJsZW5ndGgiLCJuZXdQcmVDdXJzb3JTdHIiLCJzbGljZSIsIm1vdmVMZWZ0IiwiZm9yY2VVcGRhdGUiLCJpbnNlcnRUZXh0IiwicGFzdGVkVGV4dCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwiY3Vyc29yUG9zIiwiZ2V0Q3Vyc29yUG9zIiwiV2ViVGVybWluYWxDdXJzb3IiLCJpbnB1dE1ldGhvZCIsIm5ld1BvcyIsImFtb3VudCIs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RXFCO0FBQUEsV0FBWkEsTUFBWSx1RUFBSCxDQUFHOztBQUNwQixXQUFJLEtBQUsxRSxLQUFMLENBQVdxRSxTQUFYLEdBQXVCLEtBQUtoRCxRQUFMLEdBQWdCdUMsTUFBM0MsRUFDRSxLQUFLZSxZQUFMLENBQWtCLEtBQUtMLFlBQUwsS0FBc0JJLE1BQXhDO0FBQ0g7OztzQ0FFZ0I7QUFDZixZQUFLQyxZQUFMLENBQWtCLENBQWxCO0FBQ0Q7OztpQ0FFVztBQUNWLFlBQUtBLFlBQUwsQ0FBa0IsS0FBS3RELFFBQUwsR0FBZ0J1QyxNQUFsQztBQUNEOzs7cUNBRWU7QUFDZCxjQUFPLEtBQUt2QyxRQUFMLEdBQWdCdUQsTUFBaEIsQ0FBdUIsS0FBS04sWUFBTCxFQUF2QixDQUFQO0FBQ0Q7Ozs4QkFFUTtBQUNMLFdBQU1PLGFBQWEsS0FBS3BCLGFBQUwsRUFBbkI7QUFDQSxjQUNFO0FBQUE7QUFBQSxXQUFNLFdBQVUsMkJBQWhCO0FBQTZDb0Isd0JBQWUsRUFBZixHQUFvQixHQUFwQixHQUEwQkE7QUFBdkUsUUFERjtBQUdIOzs7O0dBakQwQyxnQkFBTXhDLFM7O21CQUFoQ2tDLGlCIiwiZmlsZSI6InJlYWN0LXdlYi10ZXJtaW5hbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIlJlYWN0XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcIlJlYWN0XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIldlYlRlcm1pbmFsXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiUmVhY3RcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIldlYlRlcm1pbmFsXCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV82X18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNGFhMTIwYTBjNWFhMzU0ZWVhNjQiLCJpbXBvcnQgJy4vY29tcG9uZW50cy9yZWFjdC13ZWItdGVybWluYWwvcmVhY3Qtd2ViLXRlcm1pbmFsLnNjc3MnO1xuaW1wb3J0IFdlYlRlcm1pbmFsIGZyb20gJy4vY29tcG9uZW50cy9yZWFjdC13ZWItdGVybWluYWwvcmVhY3Qtd2ViLXRlcm1pbmFsLmpzeCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViVGVybWluYWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXguanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP291dHB1dFN0eWxlPWV4cGFuZGVkJmluY2x1ZGVQYXRoc1tdPS9Vc2Vycy9qeWFubmVzL2RldmVsb3BtZW50L3JlYWN0LXdlYi10ZXJtaW5hbC9ib3dlcl9jb21wb25lbnRzJmluY2x1ZGVQYXRoc1tdPS9Vc2Vycy9qeWFubmVzL2RldmVsb3BtZW50L3JlYWN0LXdlYi10ZXJtaW5hbC9ub2RlX21vZHVsZXMhLi9yZWFjdC13ZWItdGVybWluYWwuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/b3V0cHV0U3R5bGU9ZXhwYW5kZWQmaW5jbHVkZVBhdGhzW109L1VzZXJzL2p5YW5uZXMvZGV2ZWxvcG1lbnQvcmVhY3Qtd2ViLXRlcm1pbmFsL2Jvd2VyX2NvbXBvbmVudHMmaW5jbHVkZVBhdGhzW109L1VzZXJzL2p5YW5uZXMvZGV2ZWxvcG1lbnQvcmVhY3Qtd2ViLXRlcm1pbmFsL25vZGVfbW9kdWxlcyEuL3JlYWN0LXdlYi10ZXJtaW5hbC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/b3V0cHV0U3R5bGU9ZXhwYW5kZWQmaW5jbHVkZVBhdGhzW109L1VzZXJzL2p5YW5uZXMvZGV2ZWxvcG1lbnQvcmVhY3Qtd2ViLXRlcm1pbmFsL2Jvd2VyX2NvbXBvbmVudHMmaW5jbHVkZVBhdGhzW109L1VzZXJzL2p5YW5uZXMvZGV2ZWxvcG1lbnQvcmVhY3Qtd2ViLXRlcm1pbmFsL25vZGVfbW9kdWxlcyEuL3JlYWN0LXdlYi10ZXJtaW5hbC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL3JlYWN0LXdlYi10ZXJtaW5hbC9yZWFjdC13ZWItdGVybWluYWwuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAa2V5ZnJhbWVzIGN1cnNvci1ibGluayB7XFxuICA1MCUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgfVxcbn1cXG5cXG4ucmVhY3Qtd2ViLXRlcm1pbmFsIHtcXG4gIGhlaWdodDogY2FsYygxMDAlIC0gKDIgKiAxNnB4KSk7XFxuICB3aWR0aDogY2FsYygxMDAlIC0gKDIgKiAxNnB4KSk7XFxuICBwYWRkaW5nOiAxNnB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwMDtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG92ZXJmbG93OiBzY3JvbGw7XFxufVxcblxcbi5yZWFjdC13ZWItdGVybWluYWwgcHJlIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbi5yZWFjdC13ZWItdGVybWluYWwgLnJlYWN0LXdlYi10ZXJtaW5hbC1pbnB1dCB7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG4ucmVhY3Qtd2ViLXRlcm1pbmFsOmZvY3VzIC5yZWFjdC13ZWItdGVybWluYWwtaW5wdXQgLnJlYWN0LXdlYi10ZXJtaW5hbC1pbnB1dC1idWZmZXIgLnJlYWN0LXdlYi10ZXJtaW5hbC1jdXJzb3Ige1xcbiAgYW5pbWF0aW9uOiBjdXJzb3ItYmxpbmsgMXMgbGluZWFyIGluZmluaXRlO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXI/b3V0cHV0U3R5bGU9ZXhwYW5kZWQmaW5jbHVkZVBhdGhzW109L1VzZXJzL2p5YW5uZXMvZGV2ZWxvcG1lbnQvcmVhY3Qtd2ViLXRlcm1pbmFsL2Jvd2VyX2NvbXBvbmVudHMmaW5jbHVkZVBhdGhzW109L1VzZXJzL2p5YW5uZXMvZGV2ZWxvcG1lbnQvcmVhY3Qtd2ViLXRlcm1pbmFsL25vZGVfbW9kdWxlcyEuL3NyYy9jb21wb25lbnRzL3JlYWN0LXdlYi10ZXJtaW5hbC9yZWFjdC13ZWItdGVybWluYWwuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbztcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBtZW1vO1xuXHRcdH07XG5cdH0sXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdChzZWxmLm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cdH0pLFxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblx0fSksXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdFx0fVxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcblx0XHRpZihuZXdPYmopIHtcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0aWYoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcblxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHtnZXRLZXlTdHJva2V9IGZyb20gJy4vcmVhY3Qtd2ViLXRlcm1pbmFsLWtleWJvYXJkLWRhdGEnO1xuaW1wb3J0IFdlYlRlcm1pbmFsSW5wdXQgZnJvbSAnLi9yZWFjdC13ZWItdGVybWluYWwtaW5wdXQuanN4JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViVGVybWluYWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAvLyBUT0RPIGFkZCBpbmxpbmUgc3R5bGVzIHNvIHRoZXkgY2FuIGJlIGNoYW5nZWQgZHluYW1pY2FsbHlcbiAgLy8gVE9ETyBhZGQgYWJpbGl0eSB0byBkaXNhYmxlL2VuYWJsZSBpbnB1dCBidWZmZXJcbiAgLy8gVE9ETyBhZGQgYWpheCBjYWxsIGZ1bmN0aW9uIHRoYXQgZGlzYWJsZXMgaW5wdXQgdGhlbiByZS1lbmFibGVzIGFmdGVyIGNhbGxiYWNrIHJ1bnNcbiAgLy8gVE9ETyB1bmljb2RlIHN1cHBvcnRcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbG9nOiBbXSxcbiAgICAgIGxvZ0lkOiAwLFxuICAgICAgY29tbWFuZEhhbmRsZXI6IHByb3BzLmNvbW1hbmRIYW5kbGVyID8gcHJvcHMuY29tbWFuZEhhbmRsZXIgOiBjb21wb25lbnQgPT4gY29tcG9uZW50Lm91dHB1dChjb21wb25lbnQuaW5wdXQoKSksXG4gICAgICBrZXlTdHJva2VNYXA6IHByb3BzLmtleVN0cm9rZU1hcCB8fCB7fSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHJlYWN0V2ViVGVybWluYWw6IHt9LFxuICAgICAgICByZWFjdFdlYlRlcm1pbmFsSW5wdXQ6IHt9LFxuICAgICAgICByZWFjdFdlYlRlcm1pbmFsSW5wdXRCdWZmZXI6IHt9LFxuICAgICAgICByZWFjdFdlYlRlcm1pbmFsQ3Vyc29yOiB7fVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5yb290LnNjcm9sbFRvcCA9IHRoaXMucm9vdC5zY3JvbGxIZWlnaHQ7XG4gIH1cblxuICBhZGRUb0xvZyh0ZXh0LCBjbGFzc05hbWUpIHtcbiAgICB0aGlzLnN0YXRlLmxvZy5wdXNoKHtcbiAgICAgICdpZCc6IHRoaXMuc3RhdGUubG9nSWQsXG4gICAgICAnY2xhc3MnOiBjbGFzc05hbWUsXG4gICAgICAndGV4dCc6IHRleHRcbiAgICB9KTtcblxuICAgIHRoaXMuc3RhdGUubG9nSWQrKztcblxuICAgIHRoaXMuc2V0U3RhdGUodGhpcy5zdGF0ZSk7XG4gIH1cblxuICBpbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dENvbXAuZ2V0SW5wdXQoKTtcbiAgfVxuXG4gIG91dHB1dChvdXRwdXQpIHtcbiAgICB0aGlzLmFkZFRvTG9nKG91dHB1dCwgJ3JlYWN0LXdlYi10ZXJtaW5hbC1vdXRwdXQnKTtcblxuICAgIHRoaXMucmVzZXRJbnB1dEJ1ZmZlcigpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh0aGlzLnN0YXRlKTtcbiAgfVxuXG4gIHJlc2V0SW5wdXRCdWZmZXIoKSB7XG4gICAgdGhpcy5pbnB1dENvbXAucmVzZXRJbnB1dEJ1ZmZlcigpO1xuICB9XG5cbiAgaGFuZGxlS2V5RG93bihlKSB7XG4gICAgaWYgKCF0aGlzLmtleVN0cm9rZU1hcEhhbmRsZXIoZSkpIHRoaXMuaW5wdXRDb21wLmhhbmRsZUtleURvd24oZSk7XG4gIH1cblxuICBvblBhc3RlKGUpIHtcbiAgICB0aGlzLmlucHV0Q29tcC5vblBhc3RlKGUpO1xuICB9XG5cbiAgb25Db21tYW5kRW50ZXJlZCgpIHtcbiAgICB0aGlzLmFkZFRvTG9nKHRoaXMuaW5wdXRDb21wLnN0YXRlLnByb21wdCArIHRoaXMuaW5wdXQoKSwgJ3JlYWN0LXdlYi10ZXJtaW5hbC1pbnB1dCcpO1xuICAgIHRoaXMuc3RhdGUuY29tbWFuZEhhbmRsZXIodGhpcyk7XG4gIH1cblxuICBrZXlTdHJva2VNYXBIYW5kbGVyKGUpIHtcbiAgICBjb25zdCBrZXlTdHJva2UgPSBnZXRLZXlTdHJva2UoZSk7XG4gICAgaWYgKGtleVN0cm9rZSBpbiB0aGlzLnN0YXRlLmtleVN0cm9rZU1hcClcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmtleVN0cm9rZU1hcFtrZXlTdHJva2VdKHRoaXMpICE9PSBmYWxzZSA/IHRydWUgOiBmYWxzZTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IGxvZ05vZGVzID0gdGhpcy5zdGF0ZS5sb2cubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYga2V5PXtpdGVtLmlkfSBjbGFzc05hbWU9e2l0ZW0uY2xhc3N9PlxuICAgICAgICAgIDxwcmU+e2l0ZW0udGV4dH08L3ByZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgdGFiSW5kZXg9XCItMVwiIHJlZj17KHJvb3QpID0+IHsgdGhpcy5yb290ID0gcm9vdCB9fSBjbGFzc05hbWU9XCJyZWFjdC13ZWItdGVybWluYWxcIiBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpfSBvblBhc3RlPXt0aGlzLm9uUGFzdGUuYmluZCh0aGlzKX0+XG4gICAgICAgIHtsb2dOb2Rlc31cbiAgICAgICAgPFdlYlRlcm1pbmFsSW5wdXQgcmVmPXsoaW5wdXQpID0+IHsgdGhpcy5pbnB1dENvbXAgPSBpbnB1dCB9fSBwcm9tcHQ9e3RoaXMucHJvcHMucHJvbXB0fSBvbkNvbW1hbmRFbnRlcmVkPXt0aGlzLm9uQ29tbWFuZEVudGVyZWQuYmluZCh0aGlzKX0gLz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL3JlYWN0LXdlYi10ZXJtaW5hbC9yZWFjdC13ZWItdGVybWluYWwuanN4IiwibW9kdWxlLmV4cG9ydHMgPSBSZWFjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIlJlYWN0XCJcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3Qga2V5bWFwID0ge1xuICAgIDg6IFsnQmFja3NwYWNlJywgJ0JhY2tzcGFjZSddLFxuICAgIDk6IFsnVGFiJywgJ1RhYiddLFxuXG4gICAgMTI6IFsnQ2xlYXInLCAnQ2xlYXInXSxcbiAgICAxMzogWydFbnRlcicsICdFbnRlciddLFxuXG4gICAgMTY6IFsnU2hpZnQnLCAnU2hpZnQnXSxcbiAgICAxNzogWydDb250cm9sJywgJ0NvbnRyb2wnXSxcbiAgICAxODogWydBbHQnLCAnQWx0J10sXG5cbiAgICAyMDogWydDYXBzTG9jaycsICdDYXBzTG9jayddLFxuXG4gICAgMjc6IFsnRXNjYXBlJywgJ0VzY2FwZSddLFxuXG4gICAgMzI6IFsnICcsICcgJ10sXG4gICAgMzM6IFsnUGFnZVVwJywgJ1BhZ2VVcCddLFxuICAgIDM0OiBbJ1BhZ2VEb3duJywgJ1BhZ2VEb3duJ10sXG4gICAgMzU6IFsnRW5kJywgJ0VuZCddLFxuICAgIDM2OiBbJ0hvbWUnLCAnSG9tZSddLFxuICAgIDM3OiBbJ0Fycm93TGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgICAzODogWydBcnJvd1VwJywgJ0Fycm93VXAnXSxcbiAgICAzOTogWydBcnJvd1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcbiAgICA0MDogWydBcnJvd0Rvd24nLCAnQXJyb3dEb3duJ10sXG5cbiAgICA0NjogWydEZWxldGUnLCAnRGVsZXRlJ10sXG5cbiAgICA0ODogWycwJywgJyknXSxcbiAgICA0OTogWycxJywgJyEnXSxcbiAgICA1MDogWycyJywgJ0AnXSxcbiAgICA1MTogWyczJywgJyMnXSxcbiAgICA1MjogWyc0JywgJyQnXSxcbiAgICA1MzogWyc1JywgJyUnXSxcbiAgICA1NDogWyc2JywgJ14nXSxcbiAgICA1NTogWyc3JywgJyYnXSxcbiAgICA1NjogWyc4JywgJyonXSxcbiAgICA1NzogWyc5JywgJygnXSxcblxuICAgIDY1OiBbJ2EnLCAnQSddLFxuICAgIDY2OiBbJ2InLCAnQiddLFxuICAgIDY3OiBbJ2MnLCAnQyddLFxuICAgIDY4OiBbJ2QnLCAnRCddLFxuICAgIDY5OiBbJ2UnLCAnRSddLFxuICAgIDcwOiBbJ2YnLCAnRiddLFxuICAgIDcxOiBbJ2cnLCAnRyddLFxuICAgIDcyOiBbJ2gnLCAnSCddLFxuICAgIDczOiBbJ2knLCAnSSddLFxuICAgIDc0OiBbJ2onLCAnSiddLFxuICAgIDc1OiBbJ2snLCAnSyddLFxuICAgIDc2OiBbJ2wnLCAnTCddLFxuICAgIDc3OiBbJ20nLCAnTSddLFxuICAgIDc4OiBbJ24nLCAnTiddLFxuICAgIDc5OiBbJ28nLCAnTyddLFxuICAgIDgwOiBbJ3AnLCAnUCddLFxuICAgIDgxOiBbJ3EnLCAnUSddLFxuICAgIDgyOiBbJ3InLCAnUiddLFxuICAgIDgzOiBbJ3MnLCAnUyddLFxuICAgIDg0OiBbJ3QnLCAnVCddLFxuICAgIDg1OiBbJ3UnLCAnVSddLFxuICAgIDg2OiBbJ3YnLCAnViddLFxuICAgIDg3OiBbJ3cnLCAnVyddLFxuICAgIDg4OiBbJ3gnLCAnWCddLFxuICAgIDg5OiBbJ3knLCAnWSddLFxuICAgIDkwOiBbJ3onLCAnWiddLFxuICAgIDkxOiBbJ01ldGEnLCAnTWV0YSddLFxuXG4gICAgMTA2OiBbJyonLCAnKiddLFxuICAgIDEwNzogWycrJywgJysnXSxcblxuICAgIDEwOTogWyctJywgJy0nXSxcbiAgICAxMTA6IFsnLicsICcuJ10sXG4gICAgMTExOiBbJy8nLCAnLyddLFxuICAgIDExMjogWydGMScsICdGMSddLFxuICAgIDExMzogWydGMicsICdGMiddLFxuICAgIDExNDogWydGMycsICdGMyddLFxuICAgIDExNTogWydGNCcsICdGNCddLFxuICAgIDExNjogWydGNScsICdGNSddLFxuICAgIDExNzogWydGNicsICdGNiddLFxuICAgIDExODogWydGNycsICdGNyddLFxuICAgIDExOTogWydGOCcsICdGOCddLFxuICAgIDEyMDogWydGOScsICdGOSddLFxuICAgIDEyMTogWydGMTAnLCAnRjEwJ10sXG4gICAgMTIyOiBbJ0YxMScsICdGMTEnXSxcbiAgICAxMjM6IFsnRjEyJywgJ0YxMiddLFxuICAgIDEyNDogWydGMTMnLCAnRjEzJ10sXG4gICAgMTI1OiBbJ0YxNCcsICdGMTQnXSxcbiAgICAxMjY6IFsnRjE1JywgJ0YxNSddLFxuICAgIDEyNzogWydGMTYnLCAnRjE2J10sXG4gICAgMTI4OiBbJ0YxNycsICdGMTcnXSxcbiAgICAxMjk6IFsnRjE4JywgJ0YxOCddLFxuICAgIDEzMDogWydGMTknLCAnRjE5J10sXG5cbiAgICAxODY6IFsnOycsICc6J10sXG4gICAgMTg3OiBbJz0nLCAnKyddLFxuICAgIDE4ODogWycsJywgJzwnXSxcbiAgICAxODk6IFsnLScsICdfJ10sXG4gICAgMTkwOiBbJy4nLCAnPiddLFxuICAgIDE5MTogWycvJywgJz8nXSxcbiAgICAxOTI6IFsnYCcsICd+J10sXG5cbiAgICAyMTk6IFsnWycsICd7J10sXG4gICAgMjIwOiBbJ1xcXFwnLCAnfCddLFxuICAgIDIyMTogWyddJywgJ30nXSxcbiAgICAyMjI6IFsnXFwnJywgJ1wiJ10sXG5cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkoZSkge1xuICAgIGxldCBrZXkgPSAnJztcbiAgICBpZiAoZS5rZXkgJiYgZS5rZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICAgIGtleSA9IGUua2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGUuc2hpZnRLZXkgPyBrZXltYXBbZS53aGljaF1bMV0gOiBrZXltYXBbZS53aGljaF1bMF07XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlTdHJva2UoZSkge1xuICAgIGNvbnN0IGtleVRlbXAgPSBnZXRLZXkoZSk7XG4gICAgY29uc3Qga2V5ID0ga2V5VGVtcCA9PT0gJyAnID8gJ1NwYWNlJyA6IGtleVRlbXA7XG5cbiAgICBsZXQga2V5U3Ryb2tlID0gW107XG4gICAgaWYgKGUuY3RybEtleSB8fCBrZXkgPT09ICdDb250cm9sJykga2V5U3Ryb2tlLnB1c2goJ0NvbnRyb2wnKTtcbiAgICBpZiAoZS5hbHRLZXkgfHwga2V5ID09PSAnQWx0Jykga2V5U3Ryb2tlLnB1c2goJ0FsdCcpO1xuICAgIGlmIChlLm1ldGFLZXkgfHwga2V5ID09PSAnTWV0YScpIGtleVN0cm9rZS5wdXNoKCdNZXRhJyk7XG4gICAgaWYgKGUuc2hpZnRLZXkgfHwga2V5ID09PSAnU2hpZnQnKSBrZXlTdHJva2UucHVzaCgnU2hpZnQnKTtcbiAgICBpZiAoa2V5U3Ryb2tlLmluZGV4T2Yoa2V5KSA9PT0gLTEpIGtleVN0cm9rZS5wdXNoKGtleSk7XG5cbiAgICByZXR1cm4ga2V5U3Ryb2tlLmpvaW4oJysnKTtcbn1cblxuZXhwb3J0IGNvbnN0IG5vblByaW50YWJsZUtleXMgPSBbXG4gICAgJ0JhY2tzcGFjZScsICdUYWInLCAnQ2xlYXInLCAnRW50ZXInLCAnU2hpZnQnLCAnQ29udHJvbCcsICdBbHQnLCAnQ2Fwc0xvY2snLCAnRXNjYXBlJywgJ1BhZ2VVcCcsICdQYWdlRG93bicsICdFbmQnLCAnSG9tZScsICdBcnJvd0xlZnQnLCAnQXJyb3dVcCcsICdBcnJvd1JpZ2h0JywgJ0Fycm93RG93bicsICdEZWxldGUnLCAnTWV0YScsXG4gICAgJ0YxJywgJ0YyJywgJ0YzJywgJ0Y0JywgJ0Y1JywgJ0Y2JywgJ0Y3JywgJ0Y4JywgJ0Y5JywgJ0YxMCcsICdGMTEnLCAnRjEyJywgJ0YxMycsICdGMTQnLCAnRjE1JywgJ0YxNicsICdGMTcnLCAnRjE4JywgJ0YxOSdcbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9yZWFjdC13ZWItdGVybWluYWwvcmVhY3Qtd2ViLXRlcm1pbmFsLWtleWJvYXJkLWRhdGEuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgV2ViVGVybWluYWxJbnB1dEJ1ZmZlciBmcm9tICcuL3JlYWN0LXdlYi10ZXJtaW5hbC1pbnB1dC1idWZmZXIuanN4JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViVGVybWluYWxJbnB1dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHByb21wdDogcHJvcHMucHJvbXB0ID8gcHJvcHMucHJvbXB0IDogJz4gJ1xuICAgIH07XG4gIH1cblxuICBnZXRJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuZ2V0SW5wdXQoKTtcbiAgfVxuXG4gIHJlc2V0SW5wdXRCdWZmZXIoKSB7XG4gICAgdGhpcy5idWZmZXIucmVzZXRJbnB1dEJ1ZmZlcigpO1xuICB9XG5cbiAgaGFuZGxlS2V5RG93bihlKSB7XG4gICAgdGhpcy5idWZmZXIuaGFuZGxlS2V5RG93bihlKTtcbiAgfVxuXG4gIG9uUGFzdGUoZSkge1xuICAgIHRoaXMuYnVmZmVyLm9uUGFzdGUoZSk7XG4gIH1cblxuICBvbkNvbW1hbmRFbnRlcmVkKCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9uQ29tbWFuZEVudGVyZWQpIHRoaXMucHJvcHMub25Db21tYW5kRW50ZXJlZCgpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlYWN0LXdlYi10ZXJtaW5hbC1pbnB1dFwiPlxuICAgICAgICA8cHJlPnt0aGlzLnN0YXRlLnByb21wdH08V2ViVGVybWluYWxJbnB1dEJ1ZmZlciByZWY9eyhidWZmZXIpID0+IHsgdGhpcy5idWZmZXIgPSBidWZmZXI7IH19IG9uQ29tbWFuZEVudGVyZWQ9e3RoaXMub25Db21tYW5kRW50ZXJlZC5iaW5kKHRoaXMpfSAvPjwvcHJlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvcmVhY3Qtd2ViLXRlcm1pbmFsL3JlYWN0LXdlYi10ZXJtaW5hbC1pbnB1dC5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQge2dldEtleSwgbm9uUHJpbnRhYmxlS2V5c30gZnJvbSAnLi9yZWFjdC13ZWItdGVybWluYWwta2V5Ym9hcmQtZGF0YSc7XG5pbXBvcnQgV2ViVGVybWluYWxDdXJzb3IgZnJvbSAnLi9yZWFjdC13ZWItdGVybWluYWwtY3Vyc29yLmpzeCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYlRlcm1pbmFsSW5wdXRCdWZmZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpbnB1dDogJydcbiAgICB9O1xuICB9XG5cbiAgZ2V0SW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaW5wdXQ7XG4gIH1cblxuICByZXNldElucHV0QnVmZmVyKCkge1xuICAgIHRoaXMuc3RhdGUuaW5wdXQgPSAnJztcbiAgICB0aGlzLmN1cnNvci5tb3ZlVG9CZWdpbmluZygpO1xuICB9XG5cbiAgaW5zZXJ0VGV4dCh0ZXh0KSB7XG4gICAgdGhpcy5zdGF0ZS5pbnB1dCA9IHRoaXMuZ2V0UHJlQ3Vyc29yU3RyKCkgKyB0ZXh0ICsgdGhpcy5jdXJzb3IuZ2V0Q3Vyc29yQ2hhcigpICsgdGhpcy5nZXRQb3N0Q3Vyc29yU3RyKCk7XG4gICAgdGhpcy5jdXJzb3IubW92ZVJpZ2h0KHRleHQubGVuZ3RoKTtcbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuc3RhdGUpO1xuICB9XG5cbiAgaGFuZGxlS2V5RG93bihlKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGUpO1xuICAgIGlmIChrZXkgPT09ICdFbnRlcicpIHtcbiAgICAgIHRoaXMub25Db21tYW5kRW50ZXJlZCgpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgbGV0IG5ld1ByZUN1cnNvclN0ciA9IHRoaXMuZ2V0UHJlQ3Vyc29yU3RyKCkuc2xpY2UoMCwgdGhpcy5nZXRQcmVDdXJzb3JTdHIoKS5sZW5ndGggLSAxKTtcbiAgICAgIHRoaXMuc3RhdGUuaW5wdXQgPSBuZXdQcmVDdXJzb3JTdHIgKyB0aGlzLmN1cnNvci5nZXRDdXJzb3JDaGFyKCkgKyB0aGlzLmdldFBvc3RDdXJzb3JTdHIoKTtcbiAgICAgIHRoaXMuY3Vyc29yLm1vdmVMZWZ0KCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHRoaXMuc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnQXJyb3dMZWZ0Jykge1xuICAgICAgdGhpcy5jdXJzb3IubW92ZUxlZnQoKTtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ0Fycm93UmlnaHQnKSB7XG4gICAgICB0aGlzLmN1cnNvci5tb3ZlUmlnaHQoKTtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9IGVsc2UgaWYgKG5vblByaW50YWJsZUtleXMuaW5kZXhPZihrZXkpID09PSAtMSAmJiAhZS5hbHRLZXkgJiYgIWUuY3RybEtleSAmJiAhZS5tZXRhS2V5KSB7XG4gICAgICB0aGlzLmluc2VydFRleHQoa2V5KTtcbiAgICB9XG4gIH1cblxuICBvblBhc3RlKGUpIHtcbiAgICBjb25zdCBwYXN0ZWRUZXh0ID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEoJ1RleHQnKTtcbiAgICB0aGlzLmluc2VydFRleHQocGFzdGVkVGV4dCk7XG4gIH1cblxuICBvbkNvbW1hbmRFbnRlcmVkKCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9uQ29tbWFuZEVudGVyZWQpIHRoaXMucHJvcHMub25Db21tYW5kRW50ZXJlZCgpO1xuICB9XG5cbiAgZ2V0UHJlQ3Vyc29yU3RyKCkge1xuICAgIGNvbnN0IGN1cnNvclBvcyA9IHRoaXMuY3Vyc29yID8gdGhpcy5jdXJzb3IuZ2V0Q3Vyc29yUG9zKCkgOiAwO1xuICAgIHJldHVybiB0aGlzLmdldElucHV0KCkuc2xpY2UoMCwgY3Vyc29yUG9zKTtcbiAgfVxuXG4gIGdldFBvc3RDdXJzb3JTdHIoKSB7XG4gICAgY29uc3QgY3Vyc29yUG9zID0gdGhpcy5jdXJzb3IgPyB0aGlzLmN1cnNvci5nZXRDdXJzb3JQb3MoKSA6IDA7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5wdXQoKS5zbGljZShjdXJzb3JQb3MgKyAxLCB0aGlzLmdldElucHV0KCkubGVuZ3RoKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwicmVhY3Qtd2ViLXRlcm1pbmFsLWlucHV0LWJ1ZmZlclwiPnt0aGlzLmdldFByZUN1cnNvclN0cigpfTxXZWJUZXJtaW5hbEN1cnNvciByZWY9eyhjdXJzb3IpID0+IHsgdGhpcy5jdXJzb3IgPSBjdXJzb3I7IH19IGlucHV0TWV0aG9kPXt0aGlzLmdldElucHV0LmJpbmQodGhpcyl9IC8+e3RoaXMuZ2V0UG9zdEN1cnNvclN0cigpfTwvc3Bhbj5cbiAgICApO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9yZWFjdC13ZWItdGVybWluYWwvcmVhY3Qtd2ViLXRlcm1pbmFsLWlucHV0LWJ1ZmZlci5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJUZXJtaW5hbEN1cnNvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgY3Vyc29yUG9zOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGdldElucHV0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaW5wdXRNZXRob2QgPyB0aGlzLnByb3BzLmlucHV0TWV0aG9kKCkgOiAnJztcbiAgICB9XG5cbiAgICBnZXRDdXJzb3JQb3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJzb3JQb3M7XG4gICAgfVxuXG4gICAgc2V0Q3Vyc29yUG9zKG5ld1Bvcykge1xuICAgICAgdGhpcy5zdGF0ZS5jdXJzb3JQb3MgPSBuZXdQb3M7XG4gICAgICB0aGlzLnNldFN0YXRlKHRoaXMuc3RhdGUpO1xuICAgIH1cblxuICAgIG1vdmVMZWZ0KGFtb3VudCA9IDEpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmN1cnNvclBvcyA+IDApXG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yUG9zKHRoaXMuZ2V0Q3Vyc29yUG9zKCkgLSBhbW91bnQpO1xuICAgIH1cblxuICAgIG1vdmVSaWdodChhbW91bnQgPSAxKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5jdXJzb3JQb3MgPCB0aGlzLmdldElucHV0KCkubGVuZ3RoKVxuICAgICAgICB0aGlzLnNldEN1cnNvclBvcyh0aGlzLmdldEN1cnNvclBvcygpICsgYW1vdW50KTtcbiAgICB9XG5cbiAgICBtb3ZlVG9CZWdpbmluZygpIHtcbiAgICAgIHRoaXMuc2V0Q3Vyc29yUG9zKDApO1xuICAgIH1cblxuICAgIG1vdmVUb0VuZCgpIHtcbiAgICAgIHRoaXMuc2V0Q3Vyc29yUG9zKHRoaXMuZ2V0SW5wdXQoKS5sZW5ndGgpO1xuICAgIH1cblxuICAgIGdldEN1cnNvckNoYXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnB1dCgpLmNoYXJBdCh0aGlzLmdldEN1cnNvclBvcygpKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGN1cnNvckNoYXIgPSB0aGlzLmdldEN1cnNvckNoYXIoKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJyZWFjdC13ZWItdGVybWluYWwtY3Vyc29yXCI+e2N1cnNvckNoYXIgPT09ICcnID8gJyAnIDogY3Vyc29yQ2hhcn08L3NwYW4+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvcmVhY3Qtd2ViLXRlcm1pbmFsL3JlYWN0LXdlYi10ZXJtaW5hbC1jdXJzb3IuanN4Il0sInNvdXJjZVJvb3QiOiIifQ==